/**
 * Flipbook Generator Service
 * 
 * This service converts PDFs into interactive HTML5 flipbooks by extracting
 * page images and integrating them with the Turn.js library.
 */

const pdfjsLib = require('pdfjs-dist');
const sharp = require('sharp');
const fs = require('fs');
const path = require('path');
const { nanoid } = require('nanoid');
const logger = require('../../utils/logger');

// Set up PDF.js worker
const pdfjsWorker = require('pdfjs-dist/build/pdf.worker.entry');
pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker;

/**
 * Extract images from a PDF buffer
 * 
 * @param {Buffer} pdfBuffer - PDF file as a buffer
 * @param {number} pageCount - Number of pages to extract
 * @returns {Promise<Array>} - Array of page images as buffers
 */
async function extractPagesFromPDF(pdfBuffer, pageCount) {
  try {
    // Load the PDF document
    const data = new Uint8Array(pdfBuffer);
    const loadingTask = pdfjsLib.getDocument({ data });
    const pdfDocument = await loadingTask.promise;
    
    // Determine how many pages to extract
    const totalPages = Math.min(pdfDocument.numPages, pageCount);
    const pages = [];
    
    // Extract each page
    for (let i = 1; i <= totalPages; i++) {
      logger.info(`Extracting page ${i} of ${totalPages}`);
      
      // Get the page
      const page = await pdfDocument.getPage(i);
      
      // Set the viewport (scale = 2 for higher resolution)
      const viewport = page.getViewport({ scale: 2.0 });
      
      // Prepare canvas for rendering
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      
      // Render the page to canvas
      await page.render({
        canvasContext: context,
        viewport
      }).promise;
      
      // Convert canvas to image buffer
      const imageData = canvas.toDataURL('image/jpeg', 0.85);
      const imageBuffer = Buffer.from(imageData.split(',')[1], 'base64');
      
      // Optimize the image with sharp
      const optimizedImageBuffer = await sharp(imageBuffer)
        .jpeg({ quality: 85, progressive: true })
        .resize(1200, null, { fit: 'inside' })
        .toBuffer();
      
      pages.push({
        pageNumber: i,
        buffer: optimizedImageBuffer
      });
    }
    
    return pages;
  } catch (error) {
    logger.error(`Error extracting pages from PDF: ${error.message}`);
    
    // Fallback approach if PDF.js fails
    return extractPagesUsingPuppeteer(pdfBuffer, pageCount);
  }
}

/**
 * Fallback method to extract PDF pages using Puppeteer
 * 
 * @param {Buffer} pdfBuffer - PDF file as a buffer
 * @param {number} pageCount - Number of pages to extract
 * @returns {Promise<Array>} - Array of page images as buffers
 */
async function extractPagesUsingPuppeteer(pdfBuffer, pageCount) {
  try {
    // This is a simplified version - in production, you'd handle this more robustly
    const puppeteer = require('puppeteer');
    const browser = await puppeteer.launch({
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
      headless: 'new'
    });
    
    // Create a temporary file to load the PDF
    const tempFilePath = `/tmp/temp-${nanoid()}.pdf`;
    fs.writeFileSync(tempFilePath, pdfBuffer);
    
    const page = await browser.newPage();
    await page.goto(`file://${tempFilePath}`, { waitUntil: 'networkidle0' });
    
    const pages = [];
    const totalPages = Math.min(pageCount, await page.evaluate(() => PDFViewerApplication.pagesCount));
    
    for (let i = 1; i <= totalPages; i++) {
      logger.info(`Extracting page ${i} of ${totalPages} using Puppeteer fallback`);
      
      // Go to the specific page
      await page.evaluate((pageNum) => {
        PDFViewerApplication.page = pageNum;
      }, i);
      
      // Wait for page to render
      await page.waitForTimeout(500);
      
      // Screenshot the page
      const screenshot = await page.screenshot({ 
        type: 'jpeg',
        quality: 85,
        clip: await page.evaluate(() => {
          const canvas = document.querySelector('.canvasWrapper canvas');
          const rect = canvas.getBoundingClientRect();
          return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        })
      });
      
      // Optimize with sharp
      const optimizedImageBuffer = await sharp(screenshot)
        .jpeg({ quality: 85, progressive: true })
        .resize(1200, null, { fit: 'inside' })
        .toBuffer();
      
      pages.push({
        pageNumber: i,
        buffer: optimizedImageBuffer
      });
    }
    
    await browser.close();
    
    // Clean up temp file
    if (fs.existsSync(tempFilePath)) {
      fs.unlinkSync(tempFilePath);
    }
    
    return pages;
  } catch (error) {
    logger.error(`Error extracting pages using Puppeteer: ${error.message}`);
    throw new Error('Failed to extract pages from PDF');
  }
}

/**
 * Generate an HTML5 flipbook from PDF pages
 * 
 * @param {Buffer} pdfBuffer - PDF file as a buffer
 * @param {number} pageCount - Number of pages in the PDF
 * @returns {Promise<Object>} - Flipbook HTML and page images
 */
async function generateFlipbook(pdfBuffer, pageCount) {
  try {
    // Extract pages from the PDF
    const pages = await extractPagesFromPDF(pdfBuffer, pageCount);
    
    // Generate the HTML for the flipbook
    const flipbookId = `flipbook-${nanoid(10)}`;
    
    const html = `
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Digital Magazine</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
        <style>
          body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: #333;
            font-family: Arial, sans-serif;
          }
          
          #${flipbookId}-container {
            height: 100%;
            display: flex;
            flex-direction: column;
          }
          
          #${flipbookId} {
            margin: auto;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: white;
          }
          
          #${flipbookId} .page {
            background-size: 100% 100%;
          }
          
          .controls {
            display: flex;
            justify-content: center;
            padding: 15px;
            background-color: rgba(0,0,0,0.7);
            position: fixed;
            bottom: 0;
            width: 100%;
          }
          
          .controls button {
            background: transparent;
            border: none;
            color: white;
            font-size: 20px;
            margin: 0 15px;
            cursor: pointer;
            transition: transform 0.2s;
          }
          
          .controls button:hover {
            transform: scale(1.2);
          }
          
          .page-number {
            color: white;
            margin: 0 15px;
            font-size: 16px;
            line-height: 28px;
          }
          
          .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 24px;
          }
          
          @media (max-width: 768px) {
            #${flipbookId} {
              width: 100% !important;
              height: auto !important;
            }
          }
        </style>
      </head>
      <body>
        <div id="${flipbookId}-loading" class="loading">
          <div>Loading magazine... <span id="loading-progress">0%</span></div>
        </div>
        
        <div id="${flipbookId}-container">
          <div id="${flipbookId}">
            ${pages.map((page, index) => `
              <div class="page" style="background-image: url('page-${index + 1}.jpg')"></div>
            `).join('')}
          </div>
          
          <div class="controls">
            <button id="prev-btn" title="Previous page"><i class="fas fa-chevron-left"></i></button>
            <span class="page-number">Page <span id="current-page">1</span> / ${pages.length}</span>
            <button id="next-btn" title="Next page"><i class="fas fa-chevron-right"></i></button>
            <button id="zoom-in-btn" title="Zoom in"><i class="fas fa-search-plus"></i></button>
            <button id="zoom-out-btn" title="Zoom out"><i class="fas fa-search-minus"></i></button>
            <button id="fullscreen-btn" title="Fullscreen"><i class="fas fa-expand"></i></button>
          </div>
        </div>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/turn.js/3/turn.min.js"></script>
        <script>
          document.addEventListener("DOMContentLoaded", function() {
            // Preload images
            const totalImages = ${pages.length};
            let loadedImages = 0;
            
            function updateProgress() {
              const progress = Math.round((loadedImages / totalImages) * 100);
              document.getElementById('loading-progress').textContent = progress + '%';
              
              if (loadedImages >= totalImages) {
                // All images loaded, initialize flipbook
                setTimeout(initFlipbook, 500);
              }
            }
            
            // Preload all page images
            ${pages.map((page, index) => `
              const img${index} = new Image();
              img${index}.onload = function() {
                loadedImages++;
                updateProgress();
              };
              img${index}.src = 'page-${index + 1}.jpg';
            `).join('')}
            
            function initFlipbook() {
              // Hide loading screen
              document.getElementById('${flipbookId}-loading').style.display = 'none';
              
              // Calculate dimensions based on window size
              const windowWidth = window.innerWidth;
              const windowHeight = window.innerHeight;
              const isLandscape = windowWidth > windowHeight;
              
              let bookWidth, bookHeight;
              
              if (isLandscape) {
                bookHeight = windowHeight * 0.8;
                bookWidth = bookHeight * 0.77 * 2; // Maintain aspect ratio
              } else {
                bookWidth = windowWidth * 0.9;
                bookHeight = bookWidth * 1.3 / 2; // Maintain aspect ratio
              }
              
              // Initialize turn.js
              $('#${flipbookId}').turn({
                width: bookWidth,
                height: bookHeight,
                autoCenter: true,
                elevation: 50,
                gradients: true,
                duration: 1000,
                pages: ${pages.length},
                when: {
                  turning: function(e, page, view) {
                    document.getElementById('current-page').textContent = page;
                  }
                }
              });
              
              // Handle controls
              document.getElementById('prev-btn').addEventListener('click', function() {
                $('#${flipbookId}').turn('previous');
              });
              
              document.getElementById('next-btn').addEventListener('click', function() {
                $('#${flipbookId}').turn('next');
              });
              
              let currentZoom = 1;
              
              document.getElementById('zoom-in-btn').addEventListener('click', function() {
                if (currentZoom < 1.5) {
                  currentZoom += 0.1;
                  $('#${flipbookId}').css('transform', 'scale(' + currentZoom + ')');
                }
              });
              
              document.getElementById('zoom-out-btn').addEventListener('click', function() {
                if (currentZoom > 0.5) {
                  currentZoom -= 0.1;
                  $('#${flipbookId}').css('transform', 'scale(' + currentZoom + ')');
                }
              });
              
              document.getElementById('fullscreen-btn').addEventListener('click', function() {
                if (!document.fullscreenElement) {
                  document.documentElement.requestFullscreen();
                } else {
                  if (document.exitFullscreen) {
                    document.exitFullscreen();
                  }
                }
              });
              
              // Handle keyboard navigation
              $(document).keydown(function(e) {
                switch(e.keyCode) {
                  case 37: // left arrow
                    $('#${flipbookId}').turn('previous');
                    break;
                  case 39: // right arrow
                    $('#${flipbookId}').turn('next');
                    break;
                }
              });
              
              // Handle window resize
              window.addEventListener('resize', function() {
                // Debounce resize event
                if (this.resizeTimeout) clearTimeout(this.resizeTimeout);
                
                this.resizeTimeout = setTimeout(function() {
                  const windowWidth = window.innerWidth;
                  const windowHeight = window.innerHeight;
                  const isLandscape = windowWidth > windowHeight;
                  
                  let bookWidth, bookHeight;
                  
                  if (isLandscape) {
                    bookHeight = windowHeight * 0.8;
                    bookWidth = bookHeight * 0.77 * 2;
                  } else {
                    bookWidth = windowWidth * 0.9;
                    bookHeight = bookWidth * 1.3 / 2;
                  }
                  
                  $('#${flipbookId}').turn('size', bookWidth, bookHeight);
                  currentZoom = 1;
                  $('#${flipbookId}').css('transform', 'scale(1)');
                }, 200);
              });
            }
            
            // Initialize flipbook immediately if all images are cached
            if (loadedImages >= totalImages) {
              initFlipbook();
            }
          });
        </script>
      </body>
      </html>
    `;
    
    return {
      html,
      pages
    };
  } catch (error) {
    logger.error(`Error generating flipbook: ${error.message}`);
    throw new Error('Failed to generate flipbook');
  }
}

module.exports = {
  generateFlipbook
};
